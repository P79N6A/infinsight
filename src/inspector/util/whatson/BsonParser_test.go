package whatson

import(
	"fmt"
	"testing"
	"encoding/binary"
	"math"
	"strings"

	"github.com/stretchr/testify/assert"
	"github.com/vinllen/mgo/bson"
)

func TestBsonGet(t *testing.T) {
	parser := NewParser("bson")

	var(
		data []byte
		ret []byte
		err error
		retF float64
	)

	fmt.Println("TestBsonGet case 1.")
	data = []byte{48, 0, 0, 0, 7, 95, 105, 100, 0, 91, 63, 81, 140, 54, 204, 92, 14, 44, 45, 64, 69, 2, 110, 97, 109, 101, 0, 3, 0, 0, 0, 118, 49, 0, 18, 97, 103, 101, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}
	ret, err = parser.Get(data, "name")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, string(ret), "v1")

	fmt.Println("TestBsonGet case 2.")
	// { "_id" : ObjectId("5b42e23937e3c89dc97b4f05"), "name" : "v1", "age" : 15.0, "other" : { "p" : { "v" : 5.0 }, "p2" : 6.0 } }
	data = []byte{91, 0, 0, 0, 7, 95, 105, 100, 0, 91, 66, 226, 57, 55, 227, 200, 157, 201, 123, 79, 5, 2, 110, 97, 109, 101, 0, 3, 0, 0, 0, 118, 49, 0, 1, 97, 103, 101, 0, 0, 0, 0, 0, 0, 0, 46, 64, 3, 111, 116, 104, 101, 114, 0, 36, 0, 0, 0, 3, 112, 0, 16, 0, 0, 0, 1, 118, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 1, 112, 50, 0, 0, 0, 0, 0, 0, 0, 24, 64, 0, 0}
	ret, err = parser.Get(data, "other", "p2")
	retF = math.Float64frombits(binary.LittleEndian.Uint64(ret))

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, retF, 6.0)

	fmt.Println("TestBsonGet case 3.")
	// { "_id" : ObjectId("5b42e23937e3c89dc97b4f05"), "name" : "v1", "age" : 15.0, "other" : { "p" : { "v" : 5.0 }, "p2" : 6.0 } }
	data = []byte{91, 0, 0, 0, 7, 95, 105, 100, 0, 91, 66, 226, 57, 55, 227, 200, 157, 201, 123, 79, 5, 2, 110, 97, 109, 101, 0, 3, 0, 0, 0, 118, 49, 0, 1, 97, 103, 101, 0, 0, 0, 0, 0, 0, 0, 46, 64, 3, 111, 116, 104, 101, 114, 0, 36, 0, 0, 0, 3, 112, 0, 16, 0, 0, 0, 1, 118, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 1, 112, 50, 0, 0, 0, 0, 0, 0, 0, 24, 64, 0, 0}
	ret, err = parser.Get(data, "age")
	retF = math.Float64frombits(binary.LittleEndian.Uint64(ret))

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, retF, 15.0)

	fmt.Println("TestBsonGet case 4.")
	// { "_id" : ObjectId("5b42e23937e3c89dc97b4f05"), "name" : "v1", "age" : 15.0, "other" : { "p" : { "v" : 5.0 }, "p2" : 6.0 } }
	data = []byte{91, 0, 0, 0, 7, 95, 105, 100, 0, 91, 66, 226, 57, 55, 227, 200, 157, 201, 123, 79, 5, 2, 110, 97, 109, 101, 0, 3, 0, 0, 0, 118, 49, 0, 1, 97, 103, 101, 0, 0, 0, 0, 0, 0, 0, 46, 64, 3, 111, 116, 104, 101, 114, 0, 36, 0, 0, 0, 3, 112, 0, 16, 0, 0, 0, 1, 118, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 1, 112, 50, 0, 0, 0, 0, 0, 0, 0, 24, 64, 0, 0}
	ret, err = parser.Get(data, "other", "p", "v")
	retF = math.Float64frombits(binary.LittleEndian.Uint64(ret))

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, retF, 5.0)

	fmt.Println("TestBsonGet case 6.")
	// { "_id" : ObjectId("5b4319a7e865f9172bbade29"), "hello" : "world", "level0" : [ "zero", 1.0 ] }
	data = []byte{75, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 25, 167, 232, 101, 249, 23, 43, 186, 222, 41, 2, 104, 101, 108, 108, 111, 0, 6, 0, 0, 0, 119, 111, 114, 108, 100, 0, 4, 108, 101, 118, 101, 108, 48, 0, 28, 0, 0, 0, 2, 48, 0, 5, 0, 0, 0, 122, 101, 114, 111, 0, 1, 49, 0, 0, 0, 0, 0, 0, 0, 240, 63, 0, 0}
	ret, err = parser.Get(data, "hello")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, string(ret), "world")

	fmt.Println("TestBsonGet case 7.")
	// { "_id" : ObjectId("5b4319a7e865f9172bbade29"), "hello" : "world", "level0" : [ "zero", 1.0 ] }
	data = []byte{75, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 25, 167, 232, 101, 249, 23, 43, 186, 222, 41, 2, 104, 101, 108, 108, 111, 0, 6, 0, 0, 0, 119, 111, 114, 108, 100, 0, 4, 108, 101, 118, 101, 108, 48, 0, 28, 0, 0, 0, 2, 48, 0, 5, 0, 0, 0, 122, 101, 114, 111, 0, 1, 49, 0, 0, 0, 0, 0, 0, 0, 240, 63, 0, 0}
	ret, err = parser.Get(data, "level0", "[0]")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, string(ret), "zero")

	fmt.Println("TestBsonGet case 8.")
	// { "_id" : ObjectId("5b4319a7e865f9172bbade29"), "hello" : "world", "level0" : [ "zero", 1.0 ] }
	data = []byte{75, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 25, 167, 232, 101, 249, 23, 43, 186, 222, 41, 2, 104, 101, 108, 108, 111, 0, 6, 0, 0, 0, 119, 111, 114, 108, 100, 0, 4, 108, 101, 118, 101, 108, 48, 0, 28, 0, 0, 0, 2, 48, 0, 5, 0, 0, 0, 122, 101, 114, 111, 0, 1, 49, 0, 0, 0, 0, 0, 0, 0, 240, 63, 0, 0}
	ret, err = parser.Get(data, "level0", "[1]")
	retF = math.Float64frombits(binary.LittleEndian.Uint64(ret))

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, retF, 1.0)

	fmt.Println("TestBsonGet case 9.")
	// { "_id" : ObjectId("5b431ae2e865f9172bbade2a"), "hello" : "world", "leve0" : [ { "level1" : { "level2" : "end" } }, { "what" : "fuck" } ] }
	data = []byte{112, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 27, 141, 232, 101, 249, 23, 43, 186, 222, 43, 2, 104, 101, 108, 108, 111, 0, 6, 0, 0, 0, 119, 111, 114, 108, 100, 0, 4, 108, 101, 118, 101, 108, 48, 0, 65, 0, 0, 0, 3, 48, 0, 34, 0, 0, 0, 3, 108, 101, 118, 101, 108, 49, 0, 21, 0, 0, 0, 2, 108, 101, 118, 101, 108, 50, 0, 4, 0, 0, 0, 101, 110, 100, 0, 0, 0, 3, 49, 0, 20, 0, 0, 0, 2, 119, 104, 97, 116, 0, 5, 0, 0, 0, 102, 117, 99, 107, 0, 0, 0, 0}
	ret, err = parser.Get(data, "level0", "[0]", "level1", "level2")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, string(ret), "end")

	fmt.Println("TestBsonGet case 10.")
	// { "_id" : ObjectId("5b431ae2e865f9172bbade2a"), "hello" : "world", "leve0" : [ { "level1" : { "level2" : "end" } }, { "what" : "fuck" } ] }
	data = []byte{112, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 27, 141, 232, 101, 249, 23, 43, 186, 222, 43, 2, 104, 101, 108, 108, 111, 0, 6, 0, 0, 0, 119, 111, 114, 108, 100, 0, 4, 108, 101, 118, 101, 108, 48, 0, 65, 0, 0, 0, 3, 48, 0, 34, 0, 0, 0, 3, 108, 101, 118, 101, 108, 49, 0, 21, 0, 0, 0, 2, 108, 101, 118, 101, 108, 50, 0, 4, 0, 0, 0, 101, 110, 100, 0, 0, 0, 3, 49, 0, 20, 0, 0, 0, 2, 119, 104, 97, 116, 0, 5, 0, 0, 0, 102, 117, 99, 107, 0, 0, 0, 0}
	ret, err = parser.Get(data, "level0", "[1]", "what")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, string(ret), "fuck")

	fmt.Println("TestBsonGet case 11.")
	// { "_id" : ObjectId("5b431ae2e865f9172bbade2a"), "hello" : "world", "leve0" : [ { "level1" : { "level2" : "end" } }, { "what" : "fuck" } ] }
	data = []byte{112, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 27, 141, 232, 101, 249, 23, 43, 186, 222, 43, 2, 104, 101, 108, 108, 111, 0, 6, 0, 0, 0, 119, 111, 114, 108, 100, 0, 4, 108, 101, 118, 101, 108, 48, 0, 65, 0, 0, 0, 3, 48, 0, 34, 0, 0, 0, 3, 108, 101, 118, 101, 108, 49, 0, 21, 0, 0, 0, 2, 108, 101, 118, 101, 108, 50, 0, 4, 0, 0, 0, 101, 110, 100, 0, 0, 0, 3, 49, 0, 20, 0, 0, 0, 2, 119, 104, 97, 116, 0, 5, 0, 0, 0, 102, 117, 99, 107, 0, 0, 0, 0}
	ret, err = parser.Get(data, "level0", "[1]")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, ret, []byte{20, 0, 0, 0, 2, 119, 104, 97, 116, 0, 5, 0, 0, 0, 102, 117, 99, 107, 0, 0})

	fmt.Println("TestBsonGet case 12.")
	// { "_id" : ObjectId("5b431ca8e865f9172bbade2e"), "hello" : "world", "int64" : NumberLong("1234567891011121408") }
	data = []byte{54, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 28, 168, 232, 101, 249, 23, 43, 186, 222, 46, 2, 104, 101, 108, 108, 111, 0, 6, 0, 0, 0, 119, 111, 114, 108, 100, 0, 18, 105, 110, 116, 54, 52, 0, 0, 49, 210, 178, 244, 16, 34, 17, 0}
	ret, err = parser.Get(data, "int64")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, binary.LittleEndian.Uint64(ret), uint64(1234567891011121408))

	fmt.Println("TestBsonGet case 13.")
	// { "_id" : ObjectId("5b431ca8e865f9172bbade2e"), "hello" : "world", "int64" : NumberLong("1234567891011121408") }
	data = []byte{54, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 28, 168, 232, 101, 249, 23, 43, 186, 222, 46, 2, 104, 101, 108, 108, 111, 0, 6, 0, 0, 0, 119, 111, 114, 108, 100, 0, 18, 105, 110, 116, 54, 52, 0, 0, 49, 210, 178, 244, 16, 34, 17, 0}
	ret, err = parser.Get(data, "what", "the", "fuck")

	assert.Equal(t, err.Error(), "path not found", "should be error[not found]")

	fmt.Println("TestBsonGet case 14.")
	// { "_id" : ObjectId("5b431d9de865f9172bbade2f"), "array" : [ NumberLong(1), 2, "3" ] }
	data = []byte{54, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 28, 168, 232, 101, 249, 23, 43, 186, 222, 46, 2, 104, 101, 108, 108, 111, 0, 6, 0, 0, 0, 119, 111, 114, 108, 100, 0, 18, 105, 110, 116, 54, 52, 0, 0, 49, 210, 178, 244, 16, 34, 17, 0}
	ret, err = parser.Get(data, "array", "[4]")

	assert.Equal(t, err.Error(), "path not found", "should be error[not found]")

	fmt.Println("TestBsonGet case 15.")
	// { "_id" : ObjectId("5b431d9de865f9172bbade2f"), "array" : [ NumberLong(1), 2, "3" ] }
	data = []byte{65, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 30, 73, 232, 101, 249, 23, 43, 186, 222, 48, 4, 97, 114, 114, 97, 121, 0, 36, 0, 0, 0, 18, 48, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 49, 0, 0, 0, 0, 0, 0, 0, 0, 64, 2, 50, 0, 2, 0, 0, 0, 51, 0, 0, 0}
	ret, err = parser.Get(data, "array", "[0]")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, binary.LittleEndian.Uint64(ret), uint64(1))

	fmt.Println("TestBsonGet case 16.")
	// { "_id" : ObjectId("5b431d9de865f9172bbade2f"), "array" : [ NumberLong(1), 2, "3" ] }
	data = []byte{65, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 30, 73, 232, 101, 249, 23, 43, 186, 222, 48, 4, 97, 114, 114, 97, 121, 0, 36, 0, 0, 0, 18, 48, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 49, 0, 0, 0, 0, 0, 0, 0, 0, 64, 2, 50, 0, 2, 0, 0, 0, 51, 0, 0, 0}
	ret, err = parser.Get(data, "array", "[2]")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, string(ret), "3")

	fmt.Println("TestBsonGet case 17.")
	// { "_id" : ObjectId("5b431d9de865f9172bbade2f"), "array" : [ NumberLong(1), 2, "3" ] }
	data = []byte{65, 0, 0, 0, 7, 95, 105, 100, 0, 91, 67, 30, 73, 232, 101, 249, 23, 43, 186, 222, 48, 4, 97, 114, 114, 97, 121, 0, 36, 0, 0, 0, 18, 48, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 49, 0, 0, 0, 0, 0, 0, 0, 0, 64, 2, 50, 0, 2, 0, 0, 0, 51, 0, 0, 0}
	ret, err = parser.Get(data, "_id")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, ret, []byte{91, 67, 30, 73, 232, 101, 249, 23, 43, 186, 222, 48})

	fmt.Println("TestBsonGet case 18.")
	// { "_id" : ObjectId("5b47410e74d57b8d1d61f23a"), "hello" : "world", "array" : [ "i'm first", "i'm second", "i'm third", "i'm fourth" ] }
	data = []byte{121, 0, 0, 0, 7, 95, 105, 100, 0, 91, 71, 65, 14, 116, 213, 123, 141, 29, 97, 242, 58, 2, 104, 101, 108, 108, 111, 0, 6, 0, 0, 0, 119, 111, 114, 108, 100, 0, 4, 97, 114, 114, 97, 121, 0, 75, 0, 0, 0, 2, 48, 0, 10, 0, 0, 0, 105, 39, 109, 32, 102, 105, 114, 115, 116, 0, 2, 49, 0, 11, 0, 0, 0, 105, 39, 109, 32, 115, 101, 99, 111, 110, 100, 0, 2, 50, 0, 10, 0, 0, 0, 105, 39, 109, 32, 116, 104, 105, 114, 100, 0, 2, 51, 0, 11, 0, 0, 0, 105, 39, 109, 32, 102, 111, 117, 114, 116, 104, 0, 0, 0}
	ret, err = parser.Get(data, "array")

	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, ret, []byte{9, 0, 0, 0, byte(STRING), 105, 39, 109, 32, 102, 105, 114, 115, 116, 10, 0, 0, 0, byte(STRING), 105, 39, 109, 32, 115, 101, 99, 111, 110, 100, 9, 0, 0, 0, byte(STRING), 105, 39, 109, 32, 116, 104, 105, 114, 100, 10, 0, 0, 0, byte(STRING), 105, 39, 109, 32, 102, 111, 117, 114, 116, 104})

	fmt.Println("TestBsonGet case 19.")
	// { "_id" : ObjectId("5b641a04f8b97623efa30515"), "aa" : {  } }
	data = []byte{31, 0, 0, 0, 7, 95, 105, 100, 0, 91, 100, 26, 4, 248, 185, 118, 35, 239, 163, 5, 21, 3, 97, 97, 0, 5, 0, 0, 0, 0, 0}
	ret, err = parser.Get(data, "aa")
	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, ret, []byte{5, 0, 0, 0, 0}, "should be nil")

	fmt.Println("TestBsonGet case 20.")
	// { "_id" : ObjectId("5bac3df4a23d4fc0595560d1"), "map" : { "i" : 1024, "f" : 3.14, "bt" : true, "bf" : false, "n" : 999, "o" : { "s1" : "s1", "s2" : "s2", "s3" : "s3", "s4" : "s4" }, "l" : [ 1, 2, 3, 4, 5 ] }, "list" : [ 1024, 3.14, true, false, 999, { "s1" : "s1", "s2" : "s2", "s3" : "s3", "s4" : "s4" }, [ 1, 2, 3, 4, 5 ] ] }
	data = []byte{101, 1, 0, 0, 7, 95, 105, 100, 0, 91, 172, 61, 244, 162, 61, 79, 192, 89, 85, 96, 209, 3, 109, 97, 112, 0, 163, 0, 0, 0, 1, 105, 0, 0, 0, 0, 0, 0, 0, 144, 64, 1, 102, 0, 31, 133, 235, 81, 184, 30, 9, 64, 8, 98, 116, 0, 1, 8, 98, 102, 0, 0, 1, 110, 0, 0, 0, 0, 0, 0, 56, 143, 64, 3, 111, 0, 49, 0, 0, 0, 2, 115, 49, 0, 3, 0, 0, 0, 115, 49, 0, 2, 115, 50, 0, 3, 0, 0, 0, 115, 50, 0, 2, 115, 51, 0, 3, 0, 0, 0, 115, 51, 0, 2, 115, 52, 0, 3, 0, 0, 0, 115, 52, 0, 0, 4, 108, 0, 60, 0, 0, 0, 1, 48, 0, 0, 0, 0, 0, 0, 0, 240, 63, 1, 49, 0, 0, 0, 0, 0, 0, 0, 0, 64, 1, 50, 0, 0, 0, 0, 0, 0, 0, 8, 64, 1, 51, 0, 0, 0, 0, 0, 0, 0, 16, 64, 1, 52, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 0, 4, 108, 105, 115, 116, 0, 161, 0, 0, 0, 1, 48, 0, 0, 0, 0, 0, 0, 0, 144, 64, 1, 49, 0, 31, 133, 235, 81, 184, 30, 9, 64, 8, 50, 0, 1, 8, 51, 0, 0, 1, 52, 0, 0, 0, 0, 0, 0, 56, 143, 64, 3, 53, 0, 49, 0, 0, 0, 2, 115, 49, 0, 3, 0, 0, 0, 115, 49, 0, 2, 115, 50, 0, 3, 0, 0, 0, 115, 50, 0, 2, 115, 51, 0, 3, 0, 0, 0, 115, 51, 0, 2, 115, 52, 0, 3, 0, 0, 0, 115, 52, 0, 0, 4, 54, 0, 60, 0, 0, 0, 1, 48, 0, 0, 0, 0, 0, 0, 0, 240, 63, 1, 49, 0, 0, 0, 0, 0, 0, 0, 0, 64, 1, 50, 0, 0, 0, 0, 0, 0, 0, 8, 64, 1, 51, 0, 0, 0, 0, 0, 0, 0, 16, 64, 1, 52, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 0, 0}
	ret, err = parser.Get(data, "list", "[5]", "s1")
	assert.Equal(t, err, nil, "should be nil")
	assert.Equal(t, string(ret),  "s1", "should be nil")
}

// test type of Timestamp, ISODate, NumberLong
func TestBsonParse(t *testing.T) {
	parser := NewParser("bson")
	nr := 0

	{
		nr++
		fmt.Printf("TestBsonParse case %d.\n", nr)

		/*
		 * { "_id" : ObjectId("5bd58b1c6e4b3def6a6b3f35"),
		 *   "lastHeartbeatRecv" : ISODate("2018-10-28T09:50:53.880Z"),
		 *   "ts" : Timestamp(1540720247, 1),
		 *   "t" : NumberLong(4),
		 *   "pid" : NumberLong(272170000) }
		 */
		data := []byte{85, 0, 0, 0, 7, 95, 105, 100, 0, 91, 213, 139, 28, 110, 75, 61, 239, 106, 107, 63, 53, 9, 108, 97, 115, 116, 72, 101, 97, 114, 116, 98, 101, 97, 116, 82, 101, 99, 118, 0, 184, 91, 21, 186, 102, 1, 0, 0, 17, 116, 115, 0, 1, 0, 0, 0, 119, 134, 213, 91, 18, 116, 0, 4, 0, 0, 0, 0, 0, 0, 0, 18, 112, 105, 100, 0, 16, 252, 56, 16, 0, 0, 0, 0, 0}
		var tpLastHeartbeatRecv, tpTs, tpT, tpPid ValueType
		err := parser.Parse(data, func(keyPath []string, value []byte, valueType ValueType) error {
			if len(keyPath) != 0 {
				path := strings.Join(keyPath, ";")
				switch path {
				case "lastHeartbeatRecv":
					tpLastHeartbeatRecv = valueType
				case "ts":
					tpTs = valueType
				case "t":
					tpT = valueType
				case "pid":
					tpPid = valueType
				}
			}

			return nil
		})
		assert.Equal(t, err, nil, "should be nil")
		assert.Equal(t, DATETIME,  tpLastHeartbeatRecv, "should be nil") // ISODate == DATETIME
		assert.Equal(t, TIMESTAMP,  tpTs, "should be nil") // Timestamp == TIMESTAMP
		assert.Equal(t, INT64,  tpT, "should be nil") // NumberLong == INT64
		assert.Equal(t, INT64,  tpPid, "should be nil") // NumberLong == INT64
	}

	{
		nr++
		fmt.Printf("TestBsonParse case %d.\n", nr)

		// { "_id" : ObjectId("5bd59c9844f8a00cfd5b6daa"), "w" : NumberLong(53), "y" : NumberLong(205) }
		data := []byte{44, 0, 0, 0, 7, 95, 105, 100, 0, 91, 213, 156, 152, 68, 248, 160, 12, 253, 91, 109, 170, 18, 119, 0, 53, 0, 0, 0, 0, 0, 0, 0, 18, 121, 0, 205, 0, 0, 0, 0, 0, 0, 0, 0}

		var tpW, tpY ValueType
		err := parser.Parse(data, func(keyPath []string, value []byte, valueType ValueType) error {
			if len(keyPath) != 0 {
				path := strings.Join(keyPath, ";")
				switch path {
				case "w":
					tpW = valueType
				case "y":
					tpY = valueType
				default:
				}
			}

			return nil
		})
		assert.Equal(t, err, nil, "should be nil")
		assert.Equal(t, INT64,  tpW, "should be nil") // Timestamp == INT64
		assert.Equal(t, INT64,  tpY, "should be nil") // NumberLong == INT64
	}
}

func BenchmarkBsonParse(b *testing.B) {
	// fmt.Println("BenchmarkBsonParse case 1.")
	b.ResetTimer()
	b.ReportAllocs()

	parser := NewParser("bson")
	// same data in the json benchmark
	// data := []byte{101, 1, 0, 0, 7, 95, 105, 100, 0, 91, 172, 61, 244, 162, 61, 79, 192, 89, 85, 96, 209, 3, 109, 97, 112, 0, 163, 0, 0, 0, 1, 105, 0, 0, 0, 0, 0, 0, 0, 144, 64, 1, 102, 0, 31, 133, 235, 81, 184, 30, 9, 64, 8, 98, 116, 0, 1, 8, 98, 102, 0, 0, 1, 110, 0, 0, 0, 0, 0, 0, 56, 143, 64, 3, 111, 0, 49, 0, 0, 0, 2, 115, 49, 0, 3, 0, 0, 0, 115, 49, 0, 2, 115, 50, 0, 3, 0, 0, 0, 115, 50, 0, 2, 115, 51, 0, 3, 0, 0, 0, 115, 51, 0, 2, 115, 52, 0, 3, 0, 0, 0, 115, 52, 0, 0, 4, 108, 0, 60, 0, 0, 0, 1, 48, 0, 0, 0, 0, 0, 0, 0, 240, 63, 1, 49, 0, 0, 0, 0, 0, 0, 0, 0, 64, 1, 50, 0, 0, 0, 0, 0, 0, 0, 8, 64, 1, 51, 0, 0, 0, 0, 0, 0, 0, 16, 64, 1, 52, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 0, 4, 108, 105, 115, 116, 0, 161, 0, 0, 0, 1, 48, 0, 0, 0, 0, 0, 0, 0, 144, 64, 1, 49, 0, 31, 133, 235, 81, 184, 30, 9, 64, 8, 50, 0, 1, 8, 51, 0, 0, 1, 52, 0, 0, 0, 0, 0, 0, 56, 143, 64, 3, 53, 0, 49, 0, 0, 0, 2, 115, 49, 0, 3, 0, 0, 0, 115, 49, 0, 2, 115, 50, 0, 3, 0, 0, 0, 115, 50, 0, 2, 115, 51, 0, 3, 0, 0, 0, 115, 51, 0, 2, 115, 52, 0, 3, 0, 0, 0, 115, 52, 0, 0, 4, 54, 0, 60, 0, 0, 0, 1, 48, 0, 0, 0, 0, 0, 0, 0, 240, 63, 1, 49, 0, 0, 0, 0, 0, 0, 0, 0, 64, 1, 50, 0, 0, 0, 0, 0, 0, 0, 8, 64, 1, 51, 0, 0, 0, 0, 0, 0, 0, 16, 64, 1, 52, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 0, 0}
	// no array but also large
	data := []byte{119, 1, 0, 0, 7, 95, 105, 100, 0, 91, 172, 144, 184, 130, 45, 19, 80, 217, 61, 189, 142, 3, 109, 97, 112, 0, 163, 0, 0, 0, 1, 105, 0, 0, 0, 0, 0, 0, 0, 144, 64, 1, 102, 0, 31, 133, 235, 81, 184, 30, 9, 64, 8, 98, 116, 0, 1, 8, 98, 102, 0, 0, 1, 110, 0, 0, 0, 0, 0, 0, 56, 143, 64, 3, 111, 0, 49, 0, 0, 0, 2, 115, 49, 0, 3, 0, 0, 0, 115, 49, 0, 2, 115, 50, 0, 3, 0, 0, 0, 115, 50, 0, 2, 115, 51, 0, 3, 0, 0, 0, 115, 51, 0, 2, 115, 52, 0, 3, 0, 0, 0, 115, 52, 0, 0, 3, 108, 0, 60, 0, 0, 0, 1, 49, 0, 0, 0, 0, 0, 0, 0, 240, 63, 1, 50, 0, 0, 0, 0, 0, 0, 0, 0, 64, 1, 51, 0, 0, 0, 0, 0, 0, 0, 8, 64, 1, 52, 0, 0, 0, 0, 0, 0, 0, 16, 64, 1, 53, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 0, 3, 108, 105, 115, 116, 0, 179, 0, 0, 0, 1, 51, 49, 52, 0, 31, 133, 235, 81, 184, 30, 9, 64, 1, 49, 48, 50, 52, 0, 0, 0, 0, 0, 0, 0, 144, 64, 8, 98, 111, 111, 108, 0, 1, 8, 98, 111, 111, 108, 50, 0, 0, 1, 112, 112, 112, 0, 0, 0, 0, 0, 0, 56, 143, 64, 3, 105, 110, 110, 101, 114, 0, 49, 0, 0, 0, 2, 115, 49, 0, 3, 0, 0, 0, 115, 49, 0, 2, 115, 50, 0, 3, 0, 0, 0, 115, 50, 0, 2, 115, 51, 0, 3, 0, 0, 0, 115, 51, 0, 2, 115, 52, 0, 3, 0, 0, 0, 115, 52, 0, 0, 3, 108, 0, 60, 0, 0, 0, 1, 49, 0, 0, 0, 0, 0, 0, 0, 240, 63, 1, 50, 0, 0, 0, 0, 0, 0, 0, 0, 64, 1, 51, 0, 0, 0, 0, 0, 0, 0, 8, 64, 1, 52, 0, 0, 0, 0, 0, 0, 0, 16, 64, 1, 53, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 0, 0}
	for i := 0; i < b.N; i++ {
		parser.Parse(data, func(keyPath []string, value []byte, valueType ValueType) error { return nil })
	}
}

// mgo bson parser
func BenchmarkMgoBsonParse(b *testing.B) {
	b.ResetTimer()
	b.ReportAllocs()

	// same data in the json benchmark
	// data := []byte{101, 1, 0, 0, 7, 95, 105, 100, 0, 91, 172, 61, 244, 162, 61, 79, 192, 89, 85, 96, 209, 3, 109, 97, 112, 0, 163, 0, 0, 0, 1, 105, 0, 0, 0, 0, 0, 0, 0, 144, 64, 1, 102, 0, 31, 133, 235, 81, 184, 30, 9, 64, 8, 98, 116, 0, 1, 8, 98, 102, 0, 0, 1, 110, 0, 0, 0, 0, 0, 0, 56, 143, 64, 3, 111, 0, 49, 0, 0, 0, 2, 115, 49, 0, 3, 0, 0, 0, 115, 49, 0, 2, 115, 50, 0, 3, 0, 0, 0, 115, 50, 0, 2, 115, 51, 0, 3, 0, 0, 0, 115, 51, 0, 2, 115, 52, 0, 3, 0, 0, 0, 115, 52, 0, 0, 4, 108, 0, 60, 0, 0, 0, 1, 48, 0, 0, 0, 0, 0, 0, 0, 240, 63, 1, 49, 0, 0, 0, 0, 0, 0, 0, 0, 64, 1, 50, 0, 0, 0, 0, 0, 0, 0, 8, 64, 1, 51, 0, 0, 0, 0, 0, 0, 0, 16, 64, 1, 52, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 0, 4, 108, 105, 115, 116, 0, 161, 0, 0, 0, 1, 48, 0, 0, 0, 0, 0, 0, 0, 144, 64, 1, 49, 0, 31, 133, 235, 81, 184, 30, 9, 64, 8, 50, 0, 1, 8, 51, 0, 0, 1, 52, 0, 0, 0, 0, 0, 0, 56, 143, 64, 3, 53, 0, 49, 0, 0, 0, 2, 115, 49, 0, 3, 0, 0, 0, 115, 49, 0, 2, 115, 50, 0, 3, 0, 0, 0, 115, 50, 0, 2, 115, 51, 0, 3, 0, 0, 0, 115, 51, 0, 2, 115, 52, 0, 3, 0, 0, 0, 115, 52, 0, 0, 4, 54, 0, 60, 0, 0, 0, 1, 48, 0, 0, 0, 0, 0, 0, 0, 240, 63, 1, 49, 0, 0, 0, 0, 0, 0, 0, 0, 64, 1, 50, 0, 0, 0, 0, 0, 0, 0, 8, 64, 1, 51, 0, 0, 0, 0, 0, 0, 0, 16, 64, 1, 52, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 0, 0}
	// no array but also large
	data := []byte{119, 1, 0, 0, 7, 95, 105, 100, 0, 91, 172, 144, 184, 130, 45, 19, 80, 217, 61, 189, 142, 3, 109, 97, 112, 0, 163, 0, 0, 0, 1, 105, 0, 0, 0, 0, 0, 0, 0, 144, 64, 1, 102, 0, 31, 133, 235, 81, 184, 30, 9, 64, 8, 98, 116, 0, 1, 8, 98, 102, 0, 0, 1, 110, 0, 0, 0, 0, 0, 0, 56, 143, 64, 3, 111, 0, 49, 0, 0, 0, 2, 115, 49, 0, 3, 0, 0, 0, 115, 49, 0, 2, 115, 50, 0, 3, 0, 0, 0, 115, 50, 0, 2, 115, 51, 0, 3, 0, 0, 0, 115, 51, 0, 2, 115, 52, 0, 3, 0, 0, 0, 115, 52, 0, 0, 3, 108, 0, 60, 0, 0, 0, 1, 49, 0, 0, 0, 0, 0, 0, 0, 240, 63, 1, 50, 0, 0, 0, 0, 0, 0, 0, 0, 64, 1, 51, 0, 0, 0, 0, 0, 0, 0, 8, 64, 1, 52, 0, 0, 0, 0, 0, 0, 0, 16, 64, 1, 53, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 0, 3, 108, 105, 115, 116, 0, 179, 0, 0, 0, 1, 51, 49, 52, 0, 31, 133, 235, 81, 184, 30, 9, 64, 1, 49, 48, 50, 52, 0, 0, 0, 0, 0, 0, 0, 144, 64, 8, 98, 111, 111, 108, 0, 1, 8, 98, 111, 111, 108, 50, 0, 0, 1, 112, 112, 112, 0, 0, 0, 0, 0, 0, 56, 143, 64, 3, 105, 110, 110, 101, 114, 0, 49, 0, 0, 0, 2, 115, 49, 0, 3, 0, 0, 0, 115, 49, 0, 2, 115, 50, 0, 3, 0, 0, 0, 115, 50, 0, 2, 115, 51, 0, 3, 0, 0, 0, 115, 51, 0, 2, 115, 52, 0, 3, 0, 0, 0, 115, 52, 0, 0, 3, 108, 0, 60, 0, 0, 0, 1, 49, 0, 0, 0, 0, 0, 0, 0, 240, 63, 1, 50, 0, 0, 0, 0, 0, 0, 0, 0, 64, 1, 51, 0, 0, 0, 0, 0, 0, 0, 8, 64, 1, 52, 0, 0, 0, 0, 0, 0, 0, 16, 64, 1, 53, 0, 0, 0, 0, 0, 0, 0, 20, 64, 0, 0, 0}
	var empty interface{}
	for i := 0; i < b.N; i++ {
		bson.Unmarshal(data, &empty)
		// bson.Unmarshal(data, nil)
	}
}